#!/usr/bin/env python3
from __future__ import annotations

from pathlib import Path

import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

try:
    import pycountry
except ImportError as exc:
    raise SystemExit(
        "pycountry is required. Install dependencies with: pip install -r requirements.txt"
    ) from exc

from project_paths import DATA_RAW, VERSION, VERSION_DIR


ASSETS_DIR = VERSION_DIR / "assets"
HTML_DIR = ASSETS_DIR / "html"
REPORT_DIR = VERSION_DIR / "report"

OVERRIDES = {
    "Bolivia (Plurinational State of)": "BOL",
    "Venezuela (Bolivarian Republic of)": "VEN",
    "Iran (Islamic Republic of)": "IRN",
    "Syrian Arab Republic": "SYR",
    "United Republic of Tanzania": "TZA",
    "Côte d'Ivoire": "CIV",
    "Lao People's Democratic Republic": "LAO",
    "Democratic People's Republic of Korea": "PRK",
    "Republic of Korea": "KOR",
    "Republic of Moldova": "MDA",
    "Viet Nam": "VNM",
    "Cabo Verde": "CPV",
    "Türkiye": "TUR",
    "Czechia": "CZE",
    "North Macedonia": "MKD",
    "Eswatini": "SWZ",
    "United States of America": "USA",
    "Russian Federation": "RUS",
    "Brunei Darussalam": "BRN",
}


def ensure_dirs() -> None:
    ASSETS_DIR.mkdir(parents=True, exist_ok=True)
    HTML_DIR.mkdir(parents=True, exist_ok=True)
    REPORT_DIR.mkdir(parents=True, exist_ok=True)


def country_to_iso3(name: str) -> str | None:
    if not name or not isinstance(name, str):
        return None
    if name in OVERRIDES:
        return OVERRIDES[name]
    try:
        return pycountry.countries.lookup(name).alpha_3
    except LookupError:
        try:
            matches = pycountry.countries.search_fuzzy(name)
            if len(matches) == 1:
                return matches[0].alpha_3
        except LookupError:
            return None
    return None


def pick_both_sex(df: pd.DataFrame, col: str) -> str:
    values = [v for v in df[col].dropna().unique().tolist()]
    if "Both sexes" in values:
        return "Both sexes"
    if "Both" in values:
        return "Both"
    return values[0] if values else ""


def read_filtered_csv(
    path: Path,
    usecols: list[str],
    filters: dict[str, object],
    chunksize: int = 250000,
) -> pd.DataFrame:
    frames = []
    for chunk in pd.read_csv(path, usecols=usecols, dtype=str, chunksize=chunksize):
        for col, allowed in filters.items():
            if allowed is None:
                continue
            if isinstance(allowed, (list, set, tuple)):
                chunk = chunk[chunk[col].isin([str(x) for x in allowed])]
            else:
                chunk = chunk[chunk[col] == str(allowed)]
        if not chunk.empty:
            frames.append(chunk)
    if not frames:
        return pd.DataFrame(columns=usecols)
    return pd.concat(frames, ignore_index=True)


def save_chart(
    fig: go.Figure,
    name: str,
    description: str,
    source: str,
    manifest: list[dict[str, str]],
) -> None:
    file_base = f"v0_{name}"
    png_path = ASSETS_DIR / f"{file_base}.png"
    html_path = HTML_DIR / f"{file_base}.html"
    try:
        fig.write_image(png_path, scale=2)
    except Exception as exc:
        print(f"PNG export failed for {name}: {exc}")
    fig.write_html(html_path)
    manifest.append(
        {
            "file": png_path.name,
            "html": html_path.name,
            "description": description,
            "source": source,
        }
    )


def write_assets_readme(manifest: list[dict[str, str]]) -> None:
    lines = [
        "# v0 Assets",
        "",
        "PNG and HTML outputs generated by `src/v0_visuals.py`.",
        "",
    ]
    for item in manifest:
        lines.append(f"- {item['file']} | {item['description']} | source: {item['source']}")
        lines.append(f"  - html: {item['html']}")
    (ASSETS_DIR / "README.md").write_text("\n".join(lines), encoding="utf-8")


def write_filter_notes(notes: list[str]) -> None:
    lines = ["# v0 Filters and Minimal Transformations", ""]
    lines.extend(notes)
    (REPORT_DIR / "v0_filters.md").write_text("\n".join(lines), encoding="utf-8")


def make_who_charts(manifest: list[dict[str, str]], notes: list[str]) -> None:
    who_path = DATA_RAW / "who_global_master.csv"
    df = pd.read_csv(who_path)
    both_label = pick_both_sex(df, "sex")
    df = df[df["sex"] == both_label].copy()
    df["age_standardized_suicide_rate_2021"] = pd.to_numeric(
        df["age_standardized_suicide_rate_2021"], errors="coerce"
    )
    df["crude_suicide_rate_2021"] = pd.to_numeric(
        df["crude_suicide_rate_2021"], errors="coerce"
    )
    df["number_suicides_2021"] = pd.to_numeric(
        df["number_suicides_2021"], errors="coerce"
    )
    df["iso3"] = df["country"].apply(country_to_iso3)
    map_df = df[df["iso3"].notna()].copy()

    fig = px.choropleth(
        map_df,
        locations="iso3",
        color="age_standardized_suicide_rate_2021",
        hover_name="country",
        color_continuous_scale="Reds",
        title="WHO 2021 age-standardized suicide rate (Both sexes)",
    )
    save_chart(
        fig,
        "who_global_map_age_std",
        "WHO age-standardized suicide rate map (Both sexes, 2021)",
        who_path.name,
        manifest,
    )

    scatter_df = df.dropna(subset=["crude_suicide_rate_2021", "age_standardized_suicide_rate_2021"])
    fig = px.scatter(
        scatter_df,
        x="crude_suicide_rate_2021",
        y="age_standardized_suicide_rate_2021",
        color="income_group",
        size="number_suicides_2021",
        hover_name="country",
        title="Crude vs age-standardized suicide rates (Both sexes)",
    )
    if len(scatter_df) > 2:
        coeff = np.polyfit(
            scatter_df["crude_suicide_rate_2021"],
            scatter_df["age_standardized_suicide_rate_2021"],
            1,
        )
        line_x = np.linspace(
            scatter_df["crude_suicide_rate_2021"].min(),
            scatter_df["crude_suicide_rate_2021"].max(),
            100,
        )
        line_y = coeff[0] * line_x + coeff[1]
        fig.add_trace(go.Scatter(x=line_x, y=line_y, mode="lines", name="Trend"))
    save_chart(
        fig,
        "who_scatter_crude_vs_age_std",
        "WHO crude vs age-standardized rates with trend line",
        who_path.name,
        manifest,
    )

    region_files = {
        "who_africa_region_full.csv": "Africa",
        "who_americas_region_full.csv": "Americas",
        "who_emro_region_full.csv": "EMRO",
        "who_europe_region_full.csv": "Europe",
        "who_searo_region_full.csv": "SEARO",
        "who_wpro_region_full.csv": "WPRO",
    }
    frames = []
    for filename, region in region_files.items():
        path = DATA_RAW / filename
        if not path.exists():
            continue
        reg_df = pd.read_csv(path)
        reg_df["region"] = region
        reg_df["age_standardized_suicide_rate_2021"] = pd.to_numeric(
            reg_df["age_standardized_suicide_rate_2021"], errors="coerce"
        )
        frames.append(reg_df)
    if frames:
        region_df = pd.concat(frames, ignore_index=True)
        fig = px.violin(
            region_df,
            x="region",
            y="age_standardized_suicide_rate_2021",
            color="sex",
            box=True,
            points="all",
            title="WHO regional distribution of age-standardized rates",
        )
        save_chart(
            fig,
            "who_region_violin_age_std",
            "WHO region distribution (violin) by sex",
            "WHO region files",
            manifest,
        )

    notes.append(
        "- WHO global: sex filter = Both sexes; mapped ISO3 via pycountry for map."
    )
    notes.append("- WHO regions: combined region files and plotted age-standardized rates.")


def make_depression_dalys_chart(manifest: list[dict[str, str]], notes: list[str]) -> None:
    path = DATA_RAW / "IHME-GBD_2023_DATA-dalys-causes-1.csv"
    usecols = [
        "location_name",
        "sex_name",
        "age_name",
        "cause_name",
        "measure_name",
        "metric_name",
        "year",
        "val",
    ]
    filters = {
        "cause_name": "Depressive disorders",
        "measure_name": "DALYs (Disability-Adjusted Life Years)",
        "metric_name": "Rate",
        "sex_name": "Both",
        "year": "2023",
    }
    df = read_filtered_csv(path, usecols, filters)
    df["val"] = pd.to_numeric(df["val"], errors="coerce")
    df = df.dropna(subset=["val"])
    if df.empty:
        return
    top = (
        df.sort_values("val", ascending=False)
        .groupby("age_name", as_index=False)
        .head(10)
    )
    fig = px.bar(
        top,
        x="val",
        y="location_name",
        facet_col="age_name",
        orientation="h",
        title="Depressive disorders DALYs rate (Top 10 by age group)",
    )
    fig.update_layout(
        margin=dict(l=230, r=40, t=90, b=40),
    )
    fig.for_each_annotation(lambda a: a.update(text=a.text.replace("age_name=", "")))
    fig.update_yaxes(matches=None)
    fig.update_xaxes(showticklabels=True)
    fig.update_layout(height=620)
    save_chart(
        fig,
        "gbd_depression_dalys_top10",
        "Top depressive disorders DALYs rate by age group (2023)",
        path.name,
        manifest,
    )
    notes.append(
        "- DALYs causes: Depressive disorders, DALYs Rate, Both sexes, 2023."
    )


def make_mental_deaths_small_multiples(
    manifest: list[dict[str, str]], notes: list[str]
) -> None:
    path = DATA_RAW / "IHME-GBD_2023_DATA-deaths-mental-substance-violence-1.csv"
    usecols = [
        "location_name",
        "sex_name",
        "age_name",
        "cause_name",
        "measure_name",
        "metric_name",
        "year",
        "val",
    ]
    filters = {
        "measure_name": "Deaths",
        "metric_name": "Rate",
        "year": "2023",
        "age_name": "25+ years",
        "cause_name": ["Self-harm", "Alcohol use disorders", "Drug use disorders"],
    }
    df = read_filtered_csv(path, usecols, filters)
    df["val"] = pd.to_numeric(df["val"], errors="coerce")
    df = df.dropna(subset=["val"])
    if df.empty:
        return
    top = (
        df.sort_values("val", ascending=False)
        .groupby(["cause_name", "sex_name"], as_index=False)
        .head(10)
    )
    fig = px.bar(
        top,
        x="val",
        y="location_name",
        color="sex_name",
        facet_col="cause_name",
        orientation="h",
        title="Mental/substance deaths rate (Top 10 by cause, 25+ years)",
    )
    fig.for_each_annotation(
        lambda a: a.update(
            text=(
                a.text.replace("cause_name=", "")
                .replace("Alcohol use disorders", "Alcohol use<br>disorders")
                .replace("Drug use disorders", "Drug use<br>disorders")
            ),
            font=dict(size=12),
        )
    )
    fig.update_layout(margin=dict(t=100))
    save_chart(
        fig,
        "gbd_mental_deaths_small_multiples",
        "Small multiples of deaths rate by cause and sex (2023, 25+ years)",
        path.name,
        manifest,
    )
    notes.append(
        "- Deaths mental/substance/violence: causes Self-harm, Alcohol use disorders, Drug use disorders; Rate; 2023; age 25+ years."
    )


def make_age_standardized_heatmap(
    manifest: list[dict[str, str]], notes: list[str]
) -> None:
    path = DATA_RAW / "IHME-GBD_2023_DATA-age-standardized-death-rate-1.csv"
    usecols = [
        "location_name",
        "sex_name",
        "age_name",
        "cause_name",
        "measure_name",
        "metric_name",
        "year",
        "val",
    ]
    filters = {
        "location_name": "Global",
        "measure_name": "Deaths",
        "metric_name": "Rate",
        "year": "2023",
        "age_name": "Age-standardized",
    }
    df = read_filtered_csv(path, usecols, filters)
    df["val"] = pd.to_numeric(df["val"], errors="coerce")
    df = df.dropna(subset=["val"])
    if df.empty:
        return
    preferred_sex = "Both" if "Both" in df["sex_name"].unique() else df["sex_name"].unique()[0]
    top_causes = (
        df[df["sex_name"] == preferred_sex]
        .sort_values("val", ascending=False)
        .head(20)["cause_name"]
        .tolist()
    )
    pivot = (
        df[df["cause_name"].isin(top_causes)]
        .pivot_table(index="cause_name", columns="sex_name", values="val", aggfunc="mean")
        .sort_values(by=preferred_sex, ascending=False)
    )
    fig = px.imshow(
        pivot,
        color_continuous_scale="RdBu",
        title="Global age-standardized death rate by cause and sex (2023)",
    )
    save_chart(
        fig,
        "gbd_age_standardized_heatmap",
        "Heatmap of global age-standardized death rate by cause and sex",
        path.name,
        manifest,
    )
    notes.append(
        "- Age-standardized death rate: Global, Deaths Rate, 2023, Age-standardized."
    )


def make_allcause_trend(manifest: list[dict[str, str]], notes: list[str]) -> None:
    path = DATA_RAW / "IHME-GBD_2023_DATA-all-cause-burden-all-ages-1.csv"
    usecols = [
        "location_name",
        "sex_name",
        "age_name",
        "cause_name",
        "measure_name",
        "metric_name",
        "year",
        "val",
    ]
    filters = {
        "location_name": "Global",
        "age_name": "All ages",
        "cause_name": "All causes",
        "measure_name": "Deaths",
        "metric_name": ["Number", "Rate"],
    }
    df = read_filtered_csv(path, usecols, filters)
    df["val"] = pd.to_numeric(df["val"], errors="coerce")
    df["year"] = pd.to_numeric(df["year"], errors="coerce")
    df = df.dropna(subset=["val", "year"])
    if df.empty:
        return
    df["metric_name"] = pd.Categorical(
        df["metric_name"],
        categories=["Number", "Rate"],
        ordered=True,
    )
    fig = px.line(
        df,
        x="year",
        y="val",
        color="sex_name",
        facet_col="metric_name",
        markers=True,
        title="Global all-cause deaths trend by metric (All ages)",
    )
    fig.update_yaxes(matches=None)
    save_chart(
        fig,
        "gbd_allcause_animated_trend",
        "Global all-cause deaths trend by metric (static facets)",
        path.name,
        manifest,
    )
    notes.append(
        "- All-cause burden: Global, All ages, Deaths, metrics Number/Rate/Percent."
    )


def make_probability_of_death_charts(
    manifest: list[dict[str, str]], notes: list[str]
) -> None:
    path = DATA_RAW / "IHME-GBD_2023_DATA-probability-of-death-1.csv"
    usecols = [
        "location_name",
        "sex_name",
        "age_name",
        "cause_name",
        "measure_name",
        "metric_name",
        "year",
        "val",
    ]
    filters = {
        "metric_name": "Probability of death",
        "year": "2023",
    }
    df = read_filtered_csv(path, usecols, filters)
    df["val"] = pd.to_numeric(df["val"], errors="coerce")
    df = df.dropna(subset=["val"])
    if df.empty:
        return
    sex_label = pick_both_sex(df, "sex_name")
    df = df[df["sex_name"] == sex_label].copy()

    candidate_causes = [
        "Self-harm",
        "Injuries",
        "Substance use disorders",
        "Mental disorders",
        "Alcohol use disorders",
    ]
    candidate_ages = ["25+ years", "20-24 years", "<20 years"]
    selection = None
    for cause in candidate_causes:
        for age in candidate_ages:
            sub = df[(df["cause_name"] == cause) & (df["age_name"] == age)]
            if not sub.empty and sub["val"].nunique() > 1:
                selection = (sub, cause, age)
                break
        if selection:
            break

    if selection is None:
        filtered = df[df["age_name"] != "All ages"].copy()
        if filtered.empty:
            filtered = df.copy()
        stats = (
            filtered.groupby(["cause_name", "age_name"], as_index=False)["val"]
            .agg(["std", "count"])
            .sort_values("std", ascending=False)
        )
        stats = stats[stats["count"] > 5]
        if not stats.empty:
            cause, age = stats.index[0]
            sub = filtered[(filtered["cause_name"] == cause) & (filtered["age_name"] == age)]
            selection = (sub, str(cause), str(age))

    if selection is None:
        cause = df["cause_name"].iloc[0]
        age = df["age_name"].iloc[0]
        selection = (df.copy(), str(cause), str(age))

    df, cause_label, age_label = selection
    df["iso3"] = df["location_name"].apply(country_to_iso3)
    map_df = df[df["iso3"].notna()].copy()

    fig = px.choropleth(
        map_df,
        locations="iso3",
        color="val",
        hover_name="location_name",
        color_continuous_scale="Blues",
        title=f"Probability of death ({cause_label}, {age_label}, 2023, {sex_label})",
    )
    save_chart(
        fig,
        "gbd_probability_of_death_map",
        f"Probability of death map ({cause_label}, {age_label}, {sex_label}, 2023)",
        path.name,
        manifest,
    )

    top = df.sort_values("val", ascending=False).head(20)
    fig = px.bar(
        top,
        x="val",
        y="location_name",
        orientation="h",
        title=f"Top 20 probability of death ({cause_label}, {age_label}, 2023)",
    )
    save_chart(
        fig,
        "gbd_probability_of_death_top20",
        f"Top 20 probability of death ({cause_label}, {age_label}, {sex_label}, 2023)",
        path.name,
        manifest,
    )
    notes.append(
        f"- Probability of death: {cause_label}, {age_label}, {sex_label}, 2023."
    )


def make_risk_factor_treemap(
    manifest: list[dict[str, str]], notes: list[str]
) -> None:
    path = DATA_RAW / "IHME-GBD_2023_DATA-risk-factor-burden-1.csv"
    usecols = [
        "location_name",
        "sex_name",
        "age_name",
        "cause_name",
        "rei_name",
        "measure_name",
        "metric_name",
        "year",
        "val",
    ]
    filters = {
        "location_name": "High-income",
        "measure_name": "Deaths",
        "metric_name": "Percent",
        "year": "2023",
    }
    df = read_filtered_csv(path, usecols, filters)
    df["val"] = pd.to_numeric(df["val"], errors="coerce")
    df = df.dropna(subset=["val"])
    if df.empty:
        return
    sex_pick = "Male" if "Male" in df["sex_name"].unique() else df["sex_name"].unique()[0]
    df = df[df["sex_name"] == sex_pick]
    fig = px.treemap(
        df,
        path=["cause_name", "rei_name"],
        values="val",
        title=f"Risk-factor burden treemap ({sex_pick}, High-income, 2023)",
    )
    save_chart(
        fig,
        "gbd_risk_factor_treemap",
        "Risk-factor burden treemap (High-income, Percent, 2023)",
        path.name,
        manifest,
    )
    notes.append(
        "- Risk-factor burden: High-income, Deaths Percent, 2023; treemap by cause and risk."
    )


def make_anemia_heatmap(manifest: list[dict[str, str]], notes: list[str]) -> None:
    path = DATA_RAW / "IHME-GBD_2023_DATA-anemia-prevalence-ylds-1.csv"
    usecols = [
        "location_name",
        "sex_name",
        "age_name",
        "cause_name",
        "rei_name",
        "measure_name",
        "metric_name",
        "year",
        "val",
    ]
    filters = {
        "location_name": "Global",
        "rei_name": "Anemia",
        "measure_name": "YLDs (Years Lived with Disability)",
        "metric_name": "Rate",
        "age_name": "All ages",
        "year": ["2020", "2021", "2022", "2023"],
    }
    df = read_filtered_csv(path, usecols, filters)
    df["val"] = pd.to_numeric(df["val"], errors="coerce")
    df["year"] = pd.to_numeric(df["year"], errors="coerce")
    df = df.dropna(subset=["val", "year"])
    if df.empty:
        return
    pivot = df.pivot_table(index="year", columns="sex_name", values="val", aggfunc="mean")
    fig = px.imshow(
        pivot,
        color_continuous_scale="Viridis",
        title="Global anemia YLDs rate by sex (2020-2023)",
    )
    save_chart(
        fig,
        "gbd_anemia_heatmap",
        "Heatmap of global anemia YLDs rate by sex (2020-2023)",
        path.name,
        manifest,
    )
    notes.append(
        "- Anemia YLDs: Global, Rate, All ages, 2020-2023."
    )


def main() -> None:
    ensure_dirs()
    if VERSION != "v0":
        print(f"Warning: MHP_VERSION is {VERSION}; outputs will be written to {VERSION_DIR}")

    manifest: list[dict[str, str]] = []
    notes: list[str] = []

    make_who_charts(manifest, notes)
    make_depression_dalys_chart(manifest, notes)
    make_mental_deaths_small_multiples(manifest, notes)
    make_age_standardized_heatmap(manifest, notes)
    make_allcause_trend(manifest, notes)
    make_probability_of_death_charts(manifest, notes)
    make_risk_factor_treemap(manifest, notes)
    make_anemia_heatmap(manifest, notes)

    write_assets_readme(manifest)
    write_filter_notes(notes)

    print(f"[{VERSION}] Generated {len(manifest)} charts in {ASSETS_DIR}")


if __name__ == "__main__":
    main()
